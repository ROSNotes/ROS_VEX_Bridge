#pragma config(UART_Usage, UART1, uartUserControl, baudRate57600, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Run the PID loop at 30 times per second */
#define PID_RATE           1     // Hz
/* Convert the rate into an interval */
const int PID_INTERVAL = 1000 / PID_RATE;
/* Track the next time we make a PID calculation */
unsigned long nextPID = PID_INTERVAL;
/* Stop the robot if it hasn't received a movement command
in this number of milliseconds */
#define AUTO_STOP_INTERVAL 2000
long lastMotorCommand = AUTO_STOP_INTERVAL;
/* Serial port baud rate */
#define BAUDRATE     57600
/* Maximum PWM signal */
#define MAX_PWM  127

/* Include definition of serial commands */
#include "commands.h"
/* Sensor functions */
//#include "sensors.h"
/* Motor driver function definitions */
#include "motor_driver.h"
/* Encoder driver function definitions for shaft encoder*/
#include "shaft_encoder_driver.h"
/* Encoder driver function definitions for shaft encoder*/
//#include "I2C_encoder_driver.h"
/* PID parameters and functions */
#include "diff_controller.h"

#include "BNSlib_HC05.h"

/* Variable initialization */

// A pair of varibles to help parse serial commands (thanks Fergs)
int arg = 0;
int index = 0;

// Variable to hold an input character
char chr;

// Variable to hold the current single-character command
char cmd;

// Character arrays to hold the first and second arguments
char argv1[16];
char argv2[16];

// The arguments converted to integers
long arg1;
long arg2;

/* Clear the current command parameters */
void resetCommand() {
	cmd = NULL;
	memset(argv1, 0, sizeof(argv1));
	memset(argv2, 0, sizeof(argv2));
	arg1 = 0;
	arg2 = 0;
	arg = 0;
	index = 0;
}

void sendUART(char *content){
	int i;
	for( i=0;content[i];i++ ){
		sendChar(UART1,content[i]);
	}
	sendChar(UART1,'\n');
}

/* Run a command.  Commands are defined in commands.h */
int runCommand() {
	int i = 0;
	int k;
	char *temp;
	char *p = argv1;
	string test;
	char *str;
	char *buffer;
	int pid_args[4];
	arg1 = atoi(argv1);
	arg2 = atoi(argv2);

	switch(cmd) {
	case GET_BAUDRATE:
		sprintf(buffer,"%d",BAUDRATE);
		sendUART(buffer);
		break;
	case ANALOG_READ:
		sprintf(buffer,"%d",SensorValue[arg1]);
		sendUART(buffer);
	case DIGITAL_READ:
		sprintf(buffer,"%d",SensorValue[arg1]);
		sendUART(buffer);
	case ANALOG_WRITE:
		SensorValue[arg1]= arg2;
		sendUART("OK");
		break;
	case DIGITAL_WRITE:
		SensorValue[arg1]=arg2;
		sendUART("OK");
		break;
	case PING:
		sprintf(buffer,"%d",SensorValue[arg1]);
		sendUART(buffer);
		break;
	case READ_ENCODERS:
		sprintf(buffer,"%d %d",readEncoder(LEFT),readEncoder(RIGHT));
		sendUART(buffer);
		break;
	case RESET_ENCODERS:
		resetEncoders();
		resetPID();
		sendUART("OK");
		break;
	case MOTOR_SPEEDS:
		/* Reset the auto stop timer */
		lastMotorCommand =nSysTime;
		if (arg1 == 0 && arg2 == 0) {
			setMotorSpeeds(0, 0);
			resetPID();
			moving = 0;
		}
		else moving = 1;
		//leftPID.TargetTicksPerFrame = arg1;
		//rightPID.TargetTicksPerFrame = arg2;
		setMotorSpeeds(arg1, arg2);
		sendUART("OK");
		break;
	case UPDATE_PID:
		stringFromChars(test, p);
		for (i=0;i<strlen(test);i++){
			if (stringGetChar(test, i)==':'){
				pid_args[k] = atoi(temp);
				k++;
			}else if (stringGetChar(test, i)=='\0'){

			}else if (stringGetChar(test, i)=='\n'){

			}else{
				temp=temp+stringGetChar(test, i);
			}

		}

		Kp = pid_args[0];
		Kd = pid_args[1];
		Ki = pid_args[2];
		Ko = pid_args[3];
		sendUART("OK");
		break;
	default:
		sendUART("Invalid Command");
		break;
	}
	return 0;
}

// This task continuously transmits sensor data.
task ReceiveData(){
	int i;
  char returnData[100];
  string temp;
	while(true)
	{
		// ReceiveData
		bnsSerialRead(UART1, returnData, 100, 100);
		if (returnData != '\0') {
			writeDebugStream(temp);
			stringFromChars(temp, returnData);
			for (i=0;i<strlen(temp);i++){
				if (stringGetChar(temp, i) == 13) {
					if (arg == 1) argv1[index] = NULL;
					else if (arg == 2) argv2[index] = NULL;
					runCommand();
					resetCommand();
				}
				// Use spaces to delimit parts of the command
				else if (stringGetChar(temp, i) == ' ') {
					// Step through the arguments
					if (arg == 0) arg = 1;
					else if (arg == 1)  {
						argv1[index] = NULL;
						arg = 2;
						index = 0;
					}
					continue;
				}
				else {
					if (arg == 0) {
						// The first arg is the single-letter command
						cmd = stringGetChar(temp, i);
					}
					else if (arg == 1) {
						// Subsequent arguments can be more than one character
						argv1[index] = stringGetChar(temp, i);
						index++;
					}
					else if (arg == 2) {
						argv2[index] = stringGetChar(temp, i);
						index++;
					}
				}
			}
		//delay(100);
		}
	}
}

task main()
{
	// Initialize the motor controller if used */
  initMotorController();
  // Initialize PID
  resetPID();
  // This should match what the AT command set the baudrate to!
	setBaudRate(UART1, baudRate57600);
	startTask(ReceiveData);
	/* Enter the main loop.  Read and parse input from the serial port
	and run any valid commands. Run a PID calculation at the target
	interval and check for auto-stop conditions.
	*/
	while(1){

		// If we are using base control, run a PID calculation at the appropriate intervals
	 // if (nSysTime > nextPID) {
	 //   updatePID();
	 //   nextPID += PID_INTERVAL;
	 // }
	  // Check to see if we have exceeded the auto-stop interval
	 // if ((nSysTime - lastMotorCommand) > AUTO_STOP_INTERVAL) {;
	  //  setMotorSpeeds(0, 0);
	  //  moving = 0;
	//  }
	//	/ Sweep servos
//		#ifdef USE_SERVOS
//		  int i;
	//	  for (i = 0; i < N_SERVOS; i++) {
	//	    servos[i].doSweep();
	//	  }
	//	#endif
//		*/

	}
}
